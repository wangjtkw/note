# 算法总结

## 一、剑指Offer

### 1、第一题（数组）

 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 

解一：暴力法（逐个遍历）

```JAVA
    public boolean Find(int target, int[][] array) {
        int row = array.length;
        int col = array[0].length;
        for (int[] ints : array) {
            for (int j = 0; j < col; j++) {
                if (ints[j] == target)
                    return true;
            }
        }
        return false;
    }
```

时间复杂度：O(N^2)

解二：从左下角开始进行查找，

```java
    public boolean Find(int target, int[][] array) {
        if (array == null || array.length == 0 || array[0].length == 0) {
            return false;
        }
        int rows = array.length - 1;
        int cols = array[0].length - 1;
        if (target < array[0][0] || target > array[rows][cols])
            return false;

        int row = rows;
        int col = 0;
        while (row >= 0 && col < cols) {
            if (array[row][col] < target) {
                col++;
            } else if (array[row][col] > target) {
                row--;
            } else {
                return true;
            }
        }
        return false;
    }
```

时间复杂度：O（N（行高+列宽））

解法三：从右上开始进行查找

```JAVA
    public boolean Find(int target, int[][] array) {
        if (array == null || array.length == 0 || array[0].length == 0) {
            return false;
        }
        int row = array.length - 1;
        int col = array[0].length - 1;
        int rowIndex = 0;
        int colIndex = col;
        while (colIndex >= 0 && rowIndex <= row) {
            if (array[rowIndex][colIndex] < target) {
                rowIndex++;
            } else if (array[rowIndex][colIndex] > target) {
                colIndex--;
            } else {
                return true;
            }
        }
        return false;
    }
```

时间复杂度：O（N（行高+列宽））

### 2、第二题（字符串）

 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 

解法一：库函数（直接调用String的replase()方法）

```java
    public String replaceSpace(StringBuffer str) {
        if (str == null || str.length() == 0)
            return "";
        String result = str.toString();
        return result.replace(" ", "%20");
    }
```

解法二：双指针（自实现）

```JAVA

    public String replaceSpace(StringBuffer str) {
        if (str == null || str.length() == 0)
            return "";
        int oldLen = str.length();
        int count = 0;
        for (int i = 0; i < oldLen; i++) {
            if (str.charAt(i) == ' ') {
                count++;
            }
        }
        int oldIndex = oldLen - 1;
        int newLen = oldLen + 2 * count;
        str.setLength(newLen);
        int newIndex = newLen - 1;
        for (; newIndex >= 0 && oldLen < newLen; oldIndex--) {
            if (str.charAt(oldIndex) == ' ') {
                str.setCharAt(newIndex--, '0');
                str.setCharAt(newIndex--, '2');
                str.setCharAt(newIndex--, '%');
            } else {
                str.setCharAt(newIndex--, str.charAt(oldIndex));
            }
            System.out.println(str.toString());
        }
        return str.toString();
    }
```

还有十字隔离法等，

String的replace()方法：

在该方法中，实际还是使用StringBuilder完成的，但如果在本身就是StringBuilder或Stringuffer的情况下使用它的实现方式反而消耗大，而解法二则是一种比较好的解法

下为String的replace()方法源码

```java
public String replace(CharSequence target, CharSequence replacement) {
        String tgtStr = target.toString();
        String replStr = replacement.toString();
    //第一个需要替换字符串的位置
        int j = indexOf(tgtStr);
        if (j < 0) {
            return this;
        }
    //被替换字符串的长度
        int tgtLen = tgtStr.length();
        int tgtLen1 = Math.max(tgtLen, 1);
    //获得当前字符串的长度
        int thisLen = length();

        int newLenHint = thisLen - tgtLen + replStr.length();
        if (newLenHint < 0) {
            throw new OutOfMemoryError();
        }
        StringBuilder sb = new StringBuilder(newLenHint);
        int i = 0;
        do {
            sb.append(this, i, j).append(replStr);
            i = j + tgtLen;
        } while (j < thisLen && (j = indexOf(tgtStr, j + tgtLen1)) > 0);
        return sb.append(this, i, thisLen).toString();
    }
```

### 3、第三题（链表）

输入一个链表，按链表从尾到头的顺序返回一个ArrayList。、

解一：新建链表，使之倒序

```java
public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ArrayList<Integer> result = new ArrayList<>();
        if (listNode == null) {
            return result;
        }
        ListNode head = new ListNode(0);
        while (listNode != null) {
            add(head, listNode.val);
            listNode = listNode.next;
        }
        ListNode first = head.next;
        while (first != null) {
            result.add(first.val);
            first = first.next;
        }
        return result;
    }
	
	//头插法
    static void add(ListNode listNode, int val) {
        ListNode temp = new ListNode(val);
        temp.next = listNode.next;
        listNode.next = temp;
    }
```

时间复杂度：O（N（2N）），空间占有率太大

解二：递归调用

```java
    ArrayList<Integer> result = new ArrayList<>();
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        if (listNode != null){
            printListFromTailToHead(listNode.next);
            result.add(listNode.val);
        }
        return result;
    }
```

解三：特殊函数调用

该种方法通过调用ArrayList的add(int,T)方法进行头插

```JAVA
    public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ArrayList<Integer> result = new ArrayList<>();
        if(listNode == null){
            return result;
        }
        while(listNode != null){
            result.add(0,listNode.val);
            listNode = listNode.next;
        }
        return result;        
    }
```

而ArrayListd的该方法其本质是调用系统的System.arraycopy()方法，需要插入一个元素就移动一次数组

解法四：栈

想到后进先出的类似的题，就应该想到栈。

```JAVA
public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
        ArrayList<Integer> result = new ArrayList<>();
        Stack<Integer> stack = new Stack<>();
        if (listNode == null) {
            return result;
        }
        while (listNode != null){
            stack.push(listNode.val);
            listNode = listNode.next;
        }
        while (!stack.isEmpty()){
            result.add(stack.pop());
        }
        return result;
    }
```

