# 算法总结

## 一、剑指Offer

### 1、第一题（数组）

 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 

解一：暴力法（逐个遍历）

```JAVA
    public boolean Find(int target, int[][] array) {
        int row = array.length;
        int col = array[0].length;
        for (int[] ints : array) {
            for (int j = 0; j < col; j++) {
                if (ints[j] == target)
                    return true;
            }
        }
        return false;
    }
```

时间复杂度：O(N^2)

解二：从左下角开始进行查找，

```java
    public boolean Find(int target, int[][] array) {
        if (array == null || array.length == 0 || array[0].length == 0) {
            return false;
        }
        int rows = array.length - 1;
        int cols = array[0].length - 1;
        if (target < array[0][0] || target > array[rows][cols])
            return false;

        int row = rows;
        int col = 0;
        while (row >= 0 && col < cols) {
            if (array[row][col] < target) {
                col++;
            } else if (array[row][col] > target) {
                row--;
            } else {
                return true;
            }
        }
        return false;
    }
```

时间复杂度：O（N（行高+列宽））

解法三：从右上开始进行查找

```JAVA
    public boolean Find(int target, int[][] array) {
        if (array == null || array.length == 0 || array[0].length == 0) {
            return false;
        }
        int row = array.length - 1;
        int col = array[0].length - 1;
        int rowIndex = 0;
        int colIndex = col;
        while (colIndex >= 0 && rowIndex <= row) {
            if (array[rowIndex][colIndex] < target) {
                rowIndex++;
            } else if (array[rowIndex][colIndex] > target) {
                colIndex--;
            } else {
                return true;
            }
        }
        return false;
    }
```

时间复杂度：O（N（行高+列宽））

### 2、第二题（StringBuffer）

 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 

解法一：库函数（直接调用String的replase()方法）

```java
    public String replaceSpace(StringBuffer str) {
        if (str == null || str.length() == 0)
            return "";
        String result = str.toString();
        return result.replace(" ", "%20");
    }
```

解法二：双指针（自实现）

```JAVA

    public String replaceSpace(StringBuffer str) {
        if (str == null || str.length() == 0)
            return "";
        int oldLen = str.length();
        int count = 0;
        for (int i = 0; i < oldLen; i++) {
            if (str.charAt(i) == ' ') {
                count++;
            }
        }
        int oldIndex = oldLen - 1;
        int newLen = oldLen + 2 * count;
        str.setLength(newLen);
        int newIndex = newLen - 1;
        for (; newIndex >= 0 && oldLen < newLen; oldIndex--) {
            if (str.charAt(oldIndex) == ' ') {
                str.setCharAt(newIndex--, '0');
                str.setCharAt(newIndex--, '2');
                str.setCharAt(newIndex--, '%');
            } else {
                str.setCharAt(newIndex--, str.charAt(oldIndex));
            }
            System.out.println(str.toString());
        }
        return str.toString();
    }
```

String的replace()方法：

在该方法中，实际还是使用StringBuilder完成的，但如果在本身就是StringBuilder或Stringuffer的情况下使用它的实现方式反而消耗大，而解法二则是一种比较好的解法

下为String的replace()方法源码

```java
public String replace(CharSequence target, CharSequence replacement) {
        String tgtStr = target.toString();
        String replStr = replacement.toString();
    //第一个需要替换字符串的位置
        int j = indexOf(tgtStr);
        if (j < 0) {
            return this;
        }
    //被替换字符串的长度
        int tgtLen = tgtStr.length();
        int tgtLen1 = Math.max(tgtLen, 1);
    //获得当前字符串的长度
        int thisLen = length();

        int newLenHint = thisLen - tgtLen + replStr.length();
        if (newLenHint < 0) {
            throw new OutOfMemoryError();
        }
        StringBuilder sb = new StringBuilder(newLenHint);
        int i = 0;
        do {
            sb.append(this, i, j).append(replStr);
            i = j + tgtLen;
        } while (j < thisLen && (j = indexOf(tgtStr, j + tgtLen1)) > 0);
        return sb.append(this, i, thisLen).toString();
    }
```

